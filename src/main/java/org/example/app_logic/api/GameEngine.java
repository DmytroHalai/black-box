package org.example.app_logic.api;

import java.util.Optional;

public interface GameEngine {
    /**
     * Виконує хід на дошці, змінює стан гри відповідно до переданого {@link Move}.
     * Перевіряє, чи не завершена гра, чи коректний гравець здійснює хід,
     * і чи не зайнята вибрана клітинка.
     *
     * @param move об’єкт {@link Move}, який містить координати (x, y) та гравця, що здійснює хід
     * @throws IllegalMoveException якщо хід некоректний (гра завершена, не його черга або клітинка зайнята)
     */
    void playTurn(Move move);

    /**
     * Скидає гру до початкового стану:
     * очищує дошку, встановлює початкового гравця (звичайно {@code X})
     * та оновлює результат гри на "триває".
     */
    void reset();

    /**
     * Повертає поточний стан дошки у вигляді об’єкта {@link BoardView},
     * який може бути використаний для візуалізації.
     *
     * @return представлення поточного стану ігрового поля
     */
    BoardView getState();

    /**
     * Повертає переможця гри (якщо він існує).
     *
     * @return {@link Optional} з {@link Player} — гравцем-переможцем, або {@code Optional.empty()} якщо ще немає переможця
     */
    Optional<Player> getWinner();

    /**
     * Перевіряє, чи гра досягла кінцевого стану (перемога або нічия).
     *
     * @return {@code true}, якщо гра завершена; {@code false} — якщо ще триває
     */
    boolean isTerminal();

    /**
     * Перевіряє коректність заданого ходу {@link Move}.
     * Хід вважається некоректним, якщо:
     * <ul>
     *   <li>гра вже завершена;</li>
     *   <li>гравець намагається ходити не у свою чергу;</li>
     *   <li>координати виходять за межі дошки 3x3;</li>
     *   <li>клітинка вже зайнята.</li>
     * </ul>
     *
     * @param move об’єкт {@link Move} для перевірки
     * @throws IllegalMoveException якщо будь-яке з правил порушено
     */
    void validateMove(Move move);

    /**
     * Повертає гравця, чий зараз хід.
     *
     * @return поточний {@link Player}
     */
    Player turn();

    /**
     * Ініціалізує ігрову дошку — створює масив клітинок {@link Cell} розміром 9 (3x3).
     * Усі клітинки заповнюються значенням {@code EMPTY}.
     */
    void initBoard();

    /**
     * Перевіряє, чи всі клітинки на дошці заповнені (тобто немає жодної {@code EMPTY}).
     *
     * @return {@code true}, якщо дошка повна; {@code false} — якщо залишились вільні клітинки
     */
    boolean isBoardFull();

    /**
     * Встановлює набір виграшних комбінацій (ліній) для гри.
     * Це 8 комбінацій: 3 горизонталі, 3 вертикалі і 2 діагоналі.
     */
    void setLines();

    /**
     * Перевіряє, чи є на дошці виграшна комбінація.
     * Якщо будь-яка лінія з {@code setLines()} заповнена однаковими символами (X або O),
     * гра вважається виграною.
     *
     * @return {@code true}, якщо є переможець; {@code false} — якщо ні
     */
    boolean hasWin();

    /**
     * Перевіряє, чи три клітинки з індексами {@code i}, {@code j}, {@code k}
     * утворюють виграшну комбінацію (усі однакові й не порожні).
     *
     * @param i перший індекс клітинки
     * @param j другий індекс клітинки
     * @param k третій індекс клітинки
     * @return {@code true}, якщо всі три клітинки мають однаковий непорожній символ; {@code false} — інакше
     */
    boolean threeInRow(int i, int j, int k);

    /**
     * Повертає внутрішній масив ігрового поля.
     * Кожен елемент масиву відповідає клітинці 3x3 дошки.
     *
     * @return масив клітинок {@link Cell} із поточним станом гри
     */
    Cell[] getBoard();

    /**
     * Перелік можливих станів однієї клітинки дошки:
     * <ul>
     *     <li>{@code EMPTY} — порожня клітинка;</li>
     *     <li>{@code X} — клітинка, зайнята гравцем X;</li>
     *     <li>{@code O} — клітинка, зайнята гравцем O.</li>
     * </ul>
     */
    enum Cell {
        EMPTY, X, O
    }
}